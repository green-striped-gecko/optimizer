---
title: "Optimizer"
author: "Gruber, Hemming-Schroeder, Otero-Jimenez, Ramsay, Ricci, and Balkenhol"
date: "August 2, 2016"
output: pdf_document
---


# Opt.landgen: A function in the PopGenReport package for optimizing a sampling design to detect landscape effects on gene flow

## Background

The main goal of the opt.landgen function in PopGenReport is to find an optimized sampling design to test if a resistance surface has a significant effect on population genetic structure in a given study system. Though landscape geometry with respect to populations substantially affects the ability to find a significant association between landscape features and population structure, this aspect has so far received little attention. The power to detect the genetic to landscape relationship depends on the difference between euclidean and landscape cost distances. The opt.landgen function works by detecting sampling designs that maximize the variance in the variance of detours (where detour is the difference between cost distance and euclidean distance) following the "Newman allocation" principle. This approach implemented in the opt.landgen function has been validated using a simulation approach which demonstrated that the optimized sampling design had increased power in detecting an effect of the landscape where a landscape effect existed (Gruber et al 2017).

In part I of this tutorial, we demonstrate how to use the opt.landgen function to design a sampling scheme. In this section, we also show how to use two features that may increase the utility of the opt.landgen function. First, we demonstrate how to use a mask on the landscape for if there are areas within the landscape of known non-habitat, so that populations in these areas are not selected. Second, we show how to fix a portion of the populations for if the opt.landgen function is being used to add additional populations after some have already been sampled. In part II of this tutorial, we show how to use the opt.landgen function post-hoc to test the relative power of a fixed sampling design.

## Set up

To use the opt.landgen function, you will need to install the PopGenReport package. For complete instructions on how to install and use PopGenReport, please refer to the PopGenReport tutorial available at: <https://cran.r-project.org/web/packages/PopGenReport/vignettes/PopGenReportIntroduction.pdf>

Load necessary packages

```{r packages}
library(PopGenReport)
library(raster)
library(hierfstat)
```


## Part I: Using opt.landgen to find an optimized sampling design

### Load the resistance surface

First we need to load our map and plot it. You can use already created cost surface or create a cost surface from any raster file. 

types of files that can be used???

Here we load a layer of the proportion of treescrub in the [describe dataset?] study area and rescale it so that cells with 100% treescrub have no cost and areas with 0% treescrub have a high cost.


```{r loadmap}

# load the raster
treeScrub <- raster("treeScrub.asc")

# the current raster shows the proportion of each cell that is treescrub
# rescale it so that cells with 100 treescrub will have a resistance of 0 and cells with no treescrub have a resistance of 10
# because of the costs of moving, an additional cost of 1 is added to each cell????
forest <- 1 + 29-treeScrub*29

# rescale the waterbodies (previously NA) 
# previously not an issue because Bernd was using a mask. can we change treescrub.asc to simplify this example? 
forest[is.na(forest[])] <- 1000

plot(forest)

```


### Use the optimizer

In addition to the resistance surface, the optimizer requires two pieces of information.

1. nlocations: the number of sampling locations to be optimized
2. method: the method of calculating the cost distance based on the gdistance package costdistance function.
..* leastcost:
..* commute:
..* SPDistance:



The following arguements have default values that can be changed to better suit your sampling scheme.

1. mindist: the minimum distance between sampling locations. Map units can be specified (default = 0 meters)
2. NN: the number of next nearest neighbor cells to be used. See function costdistance (default = 8)
3. inter: the number of iterations that should be used to find an optimised design (default = 100)
4. retry: the number of retries if optimisation is not possible in a certain iteration due to the mindist and/or fixed locations (default = 10)



Additional information can be added if some sampling locations are predetermined or not all areas of the cost surface are available for sampling.

1. fixed: a data.frame of n fixed sampling locations with dimensions n x 2
2. mask: a raster object that masks positions which are not available. Areas which are not to be used for locations are coded as NA (not available), all other values are treated as suitable for placing locations



Finally, set Plot = TRUE to produce the output of function



In this example we optimize 9 sampling locations on the forest cost surface using the least cost method. 

```{r opt function}
#set the seed of the number generator
set.seed(123) 
op <- opt.landgen(landscape = forest, nlocations = 9, mindist = 5000, method = "leastcost", NN = 8, iter = 2)

```

In order to expedite the function, we set iter = 5, which will run for 1-2 minutes. If you set iter = 100, it will run for about 30 minutes and produce a better comparison. 


### Output

```{r output, echo=FALSE}
op
```

The opt.landgen function produces a data.frame containing the standard deviation of the least cost values (sd.cost) and the standard deviation of the detours (sd.detour) for each iteration as well as the location coordinates for the sampling locations.

If plot = TRUE it will also produce four plots
1. Distribution of detour
..*the flatter the better... [neeed mre] 
2. Cummulative density of sd.detour
..* Shows the proportin of iterations with lower standard deviations
3. Best
..* The coordinates of the iteration with the highest sd.detour plotted on the cost surface
4. Worst
..* The coordinates of the iteration with the lowest sd.detour plotted on the cost surface

Because we are only going through a small number of iterations in this example, it is unlikely that we have found the optimal sampling locations or that your locations will match ours exactly. [more?]


### Use a mask

move this up to the original to take care of the water??

Suppose areas with little treescrub are known to have a high prevelence of venemous blah blah blah and sampling in these locations would be too dangerous. We can create a mask so that the optimizer will not include them as potential sample locations.


```{r define mask}

# define the mask so that cells with a proportion of treescrub less than .10 will be not available
mask <- treeScrub
mask[values(treeScrub<0.10)] <- NA

# run the optimizer 
opmask <- opt.landgen(landscape = forest, nlocations = 9, mindist=5000, method="leastcost", NN=8, iter=2, mask=mask)
```


## Part II: Using opt.landgen to test the power of your sampling design post-hoc

opt.landgen can also be used to compare your sampling design to an optimized version post-hoc. For this example, we compare the sampling of 9 populations of possums in [area the layer is from?] to the optimized version. 


### Load the sampled location data

Sampling locations should be loaded as a genind object.

```{r loadpossums}

# see function read.genetable in PopGenReport for an explanation r should we explain here???
possums <- read.genetable("possums.csv", ind=1, pop=2, lat=3, long=4,other.min=5, other.max=6, oneColPerAll=TRUE)

# the original dataset includes [#?] populations but to expedite the computational time we are restricting the dataset to the first 9 populations sampled
possums <- possums[as.numeric(pop(possums))<10,]

```

The longitude and latitude in possums is currently in [??? format]. Before plotting these locations on the forest layer, they must first be transformed to the New Zealand coordinate system.

```{r code}

# explain the functions used in this chunk???? 

pt <- possums@other$latlong
coordinates(pt) <-  ~long + lat
proj4string(pt) <-"+proj=longlat +datum=WGS84 +ellps=WGS84"

nzp4 <-  "+proj=tmerc +lat_0=0 +lon_0=173 +k=0.9996 +x_0=1600000 +y_0=10000000 +ellps=GRS80 +units=m +no_defs"

 
ptnz <-spTransform(pt, CRS(nzp4) )

possums@other$xy <- coordinates(ptnz)

# plot the sampled possums on the forest layer
plot(forest)
points(possums@other$xy)

```

The sampling data is at an individual level but we are optimizing the surface for 9 populations. We can find the median center of the individuals to compare to the optimized population locations.

```{r median center}

# find the median longitude and latitude for each population 
xys <- cbind(tapply(possums@other$xy[,1], pop(possums), median), tapply(possums@other$xy[,2], pop(possums), median))

# plot the sampled possums on the forest layer
plot(forest)
points(possums@other$xy)
# plot the median center locations on top of the forest layer and the individual possum locations
points(xys, col="orange", pch=16)

```

### Compare the sampled locations the the optimized locations

If we calculate the standard deviation of detours in the sampled locations, we can compare the amount of deviation to the cumulative distrobution of sd.detour calculated by the optimizer (plot 2 from the optimizer output).


```{r compare}

# cost distance between the sampled populations
cd <- as.dist(costdistances(landscape = forest, locs = xys, method = "leastcost", NN=8))

# euclidian distance between the sampled populations
ed <- dist(xys)

# length of detours between sampled populations calculated as the residuals of the regression of cost distance by euclidian distance 
detours <- resid(lm(cd ~ ed))

# the standard deviation of detours for the sampled populations
sddetours <- sd(detours)


# plot the cumulative distrobution of sd.detour with the sd.detour of our sampling locations overlayed

plot(ecdf(op$opt$sd.detour), main="Cummulative Density of sd.detour", xlab="cummulative frequency of sd(detours)", xlim=range(op$opt$sd.detour, sddetours))
abline(v=sddetours ,col="red")
legend("topleft", legend="your scenario", lwd=1, pch="|", col="red")

```

The sampled and optimized scenarios can also be compared visually.

```{r visual}
  
plot(treeScrub)
# sampled populations
points(xys, col="red", pch=16)
# best scenario locations
points(op$scenario[[1]] , col="blue", pch=16)

```

As you can see the sd.detour of the sampled locations is [??] compared to the cumulative distrobution....


## genetic something or other
Because we have genetics data from the sampled possums, we can see how a different sampling scheme could improve our ability to find the affect of the landscape

To do so we will be using the hierfstat package to calculate ...

```{r genetics}

# calculate the pairwise fst between possum [populations or ind?] 
gd <- pairwise.fst(possums)

# run a mantel test to test for the effect of the landscape (cd) on the genetic differences (gd) when the euclidian distance is controlled for (ed)
pm <- wassermann(gen.mat=as.matrix(gd), cost.mats=list(cd = as.matrix(cd)), eucl.mat = as.matrix(ed))

pm
```

remove gd plots?

From the mantel test we can see that we are unable to show an effect of the density of scrubtree on the genetic distance between populations when euclidian distance is accounted for.

something explaining why we are including the correlation...

```{r correlation}
# calculate the correlation between the genetic, cost, and euclidian distances between populations
cor(cbind(gd, cd, ed))
```

There is a significant relationship between the euclidian distance and genetic distance but no correlation between the cost distance and the genetic distance. This could be the case because the cost and euclidian distances quite highly correlated (0.58).

While we were unable to find a significant affect of the landscape on the genetic distances between the nine sampled populations, from our post-hoc comparisons we can see that our sampling scheme was not ideal. If we have additional funds and time to continue sampling, we can incorporate our sampled possums as fixed populations and reoptimize the landscape for more sampling locations.


```{r fix pops}
fixed <- xys
opfix <- opt.landgen(landscape = forest, nlocations = 15, mindist = 5000, method = "leastcost", NN = 8, iter = 2, mask = mask, fixed = fixed)
```


By incorporating the additional 6 sampling locations into our analysis we could shown the effect of forest.... (which we actually did using the full data set = 31 populations....)...




